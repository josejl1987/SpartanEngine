/*
Copyright(c) 2015-2026 Panos Karabelas

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//= INCLUDES =============================
#include "pch.h"
#include "Window.h"
#include "Renderer.h"
#include "Material.h"
#include "SkinningGeometryBuffer.h"
#include "../Geometry/GeometryGeneration.h"
#include "../World/Components/Light.h"
#include "../Resource/ResourceCache.h"
#include "../Display/Display.h"
#include "../RHI/RHI_Texture.h"
#include "../RHI/RHI_Shader.h"
#include "../RHI/RHI_Sampler.h"
#include "../RHI/RHI_BlendState.h"
#include "../RHI/RHI_RasterizerState.h"
#include "../RHI/RHI_DepthStencilState.h"
#include "../RHI/RHI_Buffer.h"
#include "../RHI/RHI_Device.h"
#ifdef _MSC_VER
#include "../RHI/RHI_VendorTechnology.h"
#endif
//========================================

//= NAMESPACES ===============
using namespace std;
using namespace spartan::math;
//============================

namespace spartan
{
    namespace
    {
        // graphics states
        array<shared_ptr<RHI_RasterizerState>, static_cast<uint32_t>(Renderer_RasterizerState::Max)>     rasterizer_states;
        array<shared_ptr<RHI_DepthStencilState>, static_cast<uint32_t>(Renderer_DepthStencilState::Max)> depth_stencil_states;
        array<shared_ptr<RHI_BlendState>, 3>                                                             blend_states;

        // renderer resources
        array<shared_ptr<RHI_Texture>, static_cast<uint32_t>(Renderer_RenderTarget::max)> render_targets;
        array<shared_ptr<RHI_Shader>,  static_cast<uint32_t>(Renderer_Shader::max)>       shaders;
        array<shared_ptr<RHI_Sampler>, static_cast<uint32_t>(Renderer_Sampler::Max)>      samplers;
        array<shared_ptr<RHI_Buffer>,  static_cast<uint32_t>(Renderer_Buffer::Max)>       buffers;

        // asset resources
        array<shared_ptr<RHI_Texture>, static_cast<uint32_t>(Renderer_StandardTexture::Max)> standard_textures;
        array<shared_ptr<Mesh>, static_cast<uint32_t>(MeshType::Max)>                        standard_meshes;
        shared_ptr<Font>                                                                     standard_font;
        shared_ptr<Material>                                                                 standard_material;
    }

    void Renderer::CreateBuffers()
    {
        uint32_t element_count = renderer_resource_frame_lifetime;
        #define buffer(x) buffers[static_cast<uint8_t>(x)]

        // initialization values
        uint32_t spd_counter_value = 0;
        array<Instance, renderer_max_instance_count> identity;
        identity.fill(Instance::GetIdentity());

        buffer(Renderer_Buffer::ConstantFrame)      = make_shared<RHI_Buffer>(RHI_Buffer_Type::Constant, sizeof(Cb_Frame),                           element_count,                          nullptr,            true, "frame");
        buffer(Renderer_Buffer::SpdCounter)         = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage,  static_cast<uint32_t>(sizeof(uint32_t)),    1,                                      &spd_counter_value, true, "spd_counter");
        buffer(Renderer_Buffer::MaterialParameters) = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage,  static_cast<uint32_t>(sizeof(Sb_Material)), rhi_max_array_size,                     nullptr,            true, "materials");
        buffer(Renderer_Buffer::LightParameters)    = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage,  static_cast<uint32_t>(sizeof(Sb_Light)),    rhi_max_array_size,                     nullptr,            true, "lights");
        buffer(Renderer_Buffer::DummyInstance)      = make_shared<RHI_Buffer>(RHI_Buffer_Type::Instance, sizeof(Instance),                           static_cast<uint32_t>(identity.size()), &identity,          true, "dummy_instance_buffer");
        buffer(Renderer_Buffer::GeometryInfo)       = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage,  static_cast<uint32_t>(sizeof(Sb_GeometryInfo)), rhi_max_array_size,                     nullptr,            true, "geometry_info");

        // single draw data and aabb buffers large enough for all frames; each frame writes to its
        // own offset region so the bindless descriptors never change, eliminating the race where
        // vkUpdateDescriptorSets (host-side, instantly visible under UPDATE_AFTER_BIND) would
        // change the buffer pointer while in-flight gpu commands were still reading from it
        buffer(Renderer_Buffer::DrawData) = make_shared<RHI_Buffer>(
            RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_DrawData)),
            renderer_max_draw_calls * renderer_draw_data_buffer_count, nullptr, true,
            "draw_data"
        );
        buffer(Renderer_Buffer::AABBs) = make_shared<RHI_Buffer>(
            RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_Aabb)),
            rhi_max_array_size * renderer_draw_data_buffer_count, nullptr, true,
            "aabbs"
        );

        // per-frame rotated buffers
        uint32_t draw_count_init = 0;
        for (uint32_t i = 0; i < renderer_draw_data_buffer_count; i++)
        {
            FrameResource& fr = m_frame_resources[i];

            fr.indirect_draw_args = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_IndirectDrawArgs)),
                rhi_max_array_size, nullptr, true,
                (string("indirect_draw_args_") + to_string(i)).c_str()
            );

            fr.indirect_draw_data = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_DrawData)),
                rhi_max_array_size, nullptr, true,
                (string("indirect_draw_data_") + to_string(i)).c_str()
            );

            fr.indirect_draw_args_out = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_IndirectDrawArgs)),
                rhi_max_array_size, nullptr, true,
                (string("indirect_draw_args_out_") + to_string(i)).c_str()
            );

            fr.indirect_draw_data_out = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_DrawData)),
                rhi_max_array_size, nullptr, true,
                (string("indirect_draw_data_out_") + to_string(i)).c_str()
            );

            fr.indirect_draw_count = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(uint32_t)),
                1, &draw_count_init, true,
                (string("indirect_draw_count_") + to_string(i)).c_str()
            );
        }

        // point the active buffer slots at frame 0
        const FrameResource& fr = m_frame_resources[0];
        buffer(Renderer_Buffer::IndirectDrawArgs)    = fr.indirect_draw_args;
        buffer(Renderer_Buffer::IndirectDrawData)    = fr.indirect_draw_data;
        buffer(Renderer_Buffer::IndirectDrawArgsOut) = fr.indirect_draw_args_out;
        buffer(Renderer_Buffer::IndirectDrawDataOut) = fr.indirect_draw_data_out;
        buffer(Renderer_Buffer::IndirectDrawCount)   = fr.indirect_draw_count;

        // particle buffers
        const uint32_t particle_max = 100000;
        uint32_t particle_counter_init[2] = { 0, 0 };
        buffer(Renderer_Buffer::ParticleBufferA) = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_Particle)),       particle_max, nullptr,                true, "particle_buffer_a");
        buffer(Renderer_Buffer::ParticleCounter) = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(uint32_t)),          2,            particle_counter_init,  true, "particle_counter");
        buffer(Renderer_Buffer::ParticleEmitter) = make_shared<RHI_Buffer>(RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_EmitterParams)),  1,            nullptr,                true, "particle_emitter");

        // gpu skinning buffers
        // Static input buffers (managed by SkinningGeometryBuffer, created on first skinned mesh load)
        buffer(Renderer_Buffer::SkinningVerticesIn) = nullptr; // Retrieved from SkinningGeometryBuffer::GetVerticesBuffer()
        buffer(Renderer_Buffer::SkinningIndices)     = nullptr; // Retrieved from SkinningGeometryBuffer::GetIndicesBuffer()
        buffer(Renderer_Buffer::SkinningWeights)     = nullptr; // Retrieved from SkinningGeometryBuffer::GetWeightsBuffer()

        // Per-frame buffers (created in frame resources)
        static constexpr uint32_t skinning_max_vertices = 1024 * 1024; // 1M vertices
        static constexpr uint32_t skinning_max_bones    = 1024 * 8;    // 8K bones per frame
        static constexpr uint32_t skinning_max_jobs   = 1024;

        for (uint32_t i = 0; i < renderer_draw_data_buffer_count; i++)
        {
            FrameResource& fr = m_frame_resources[i];

            // Skinning bones - per-frame bone matrix buffer (mappable for CPU upload)
            fr.skinning_bones = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_SkinningBone)),
                skinning_max_bones, nullptr, true,
                (string("skinning_bones_") + to_string(i)).c_str()
            );

            // Skinning jobs - per-frame job list (mappable for CPU upload)
            fr.skinning_jobs = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_SkinningJob)),
                skinning_max_jobs + 1, nullptr, true, // +1 for header at index 0
                (string("skinning_jobs_") + to_string(i)).c_str()
            );

            // Skinning dispatch args - per-frame indirect dispatch (mappable for CPU upload)
            uint32_t dispatch_init[3] = { 0, 1, 1 };
            fr.skinning_dispatch_args = make_shared<RHI_Buffer>(
                RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_SkinningDispatchArgs)),
                1, dispatch_init, true,
                (string("skinning_dispatch_args_") + to_string(i)).c_str()
            );
        }

        // Point active buffers at frame 0
        buffer(Renderer_Buffer::SkinningBones)       = m_frame_resources[0].skinning_bones;
        buffer(Renderer_Buffer::SkinningJobs)        = m_frame_resources[0].skinning_jobs;
        buffer(Renderer_Buffer::SkinningDispatchArgs)= m_frame_resources[0].skinning_dispatch_args;

        // Skinning output - device-local UAV buffer for compute shader output
        // Single buffer reused each frame (barriers ensure proper GPU-side ordering)
        buffer(Renderer_Buffer::SkinningVerticesOut) = make_shared<RHI_Buffer>(
            RHI_Buffer_Type::Storage, static_cast<uint32_t>(sizeof(Sb_SkinnedVertex)),
            skinning_max_vertices, nullptr, false, // device-local, not mappable
            "skinning_vertices_out"
        );
    }

    void Renderer::CreateDepthStencilStates()
    {
        #define depth_stencil_state(x) depth_stencil_states[static_cast<uint8_t>(x)]

        // arguments: depth_test, depth_write, depth_function, stencil_test, stencil_write, stencil_function
        depth_stencil_state(Renderer_DepthStencilState::Off)              = make_shared<RHI_DepthStencilState>(false, false, RHI_Comparison_Function::Never);
        depth_stencil_state(Renderer_DepthStencilState::ReadEqual)        = make_shared<RHI_DepthStencilState>(true,  false, RHI_Comparison_Function::Equal);
        depth_stencil_state(Renderer_DepthStencilState::ReadGreaterEqual) = make_shared<RHI_DepthStencilState>(true,  false, RHI_Comparison_Function::GreaterEqual);
        depth_stencil_state(Renderer_DepthStencilState::ReadWrite)        = make_shared<RHI_DepthStencilState>(true,  true,  RHI_Comparison_Function::GreaterEqual);
    }

    void Renderer::CreateRasterizerStates()
    {
        // bias done in shader, hardware bias is uncontrollable across cascades
        float bias              = 0.0f;
        float bias_clamp        = 0.0f;
        float bias_slope_scaled = 0.0f;
        float line_width        = 3.0f;

        #define rasterizer_state(x) rasterizer_states[static_cast<uint8_t>(x)]
        //                                                                                               fill mode,    depth clip enabled,  bias,   bias clamp,       slope scaled bias, line width
        rasterizer_state(Renderer_RasterizerState::Solid)             = make_shared<RHI_RasterizerState>(RHI_PolygonMode::Solid,     true,  0.0f,         0.0f,       0.0f,              line_width);
        rasterizer_state(Renderer_RasterizerState::Wireframe)         = make_shared<RHI_RasterizerState>(RHI_PolygonMode::Wireframe, true,  0.0f,         0.0f,       0.0f,              line_width);
        rasterizer_state(Renderer_RasterizerState::Light_point_spot)  = make_shared<RHI_RasterizerState>(RHI_PolygonMode::Solid,     true,  bias,         bias_clamp, bias_slope_scaled, line_width);
        rasterizer_state(Renderer_RasterizerState::Light_directional) = make_shared<RHI_RasterizerState>(RHI_PolygonMode::Solid,     false, bias * 0.5f,  bias_clamp, bias_slope_scaled, line_width);
    }

    void Renderer::CreateBlendStates()
    {
        #define blend_state(x) blend_states[static_cast<uint8_t>(x)]

        // blend_enabled, source_blend, dest_blend, blend_op, source_blend_alpha, dest_blend_alpha, blend_op_alpha, blend_factor
        blend_state(Renderer_BlendState::Off)      = make_shared<RHI_BlendState>(false);
        blend_state(Renderer_BlendState::Alpha)    = make_shared<RHI_BlendState>(true, RHI_Blend::Src_Alpha, RHI_Blend::Inv_Src_Alpha, RHI_Blend_Operation::Add, RHI_Blend::One, RHI_Blend::One, RHI_Blend_Operation::Add, 0.0f);
        blend_state(Renderer_BlendState::Additive) = make_shared<RHI_BlendState>(true, RHI_Blend::One,       RHI_Blend::One,           RHI_Blend_Operation::Add, RHI_Blend::One, RHI_Blend::One, RHI_Blend_Operation::Add, 1.0f);
    }

    void Renderer::CreateSamplers()
    {
        #define sampler(type, filter_min, filter_mag, filter_mip, address_mode, comparison_func, anisotropy, comparison_enabled, mip_bias) \
        samplers[static_cast<uint8_t>(type)] = make_shared<RHI_Sampler>(filter_min, filter_mag, filter_mip, address_mode, comparison_func, anisotropy, comparison_enabled, mip_bias)

        // non anisotropic
        {
            static bool samplers_created = false;
            if (!samplers_created)
            {
                sampler(Renderer_Sampler::Compare_depth,         RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Filter::Nearest, RHI_Sampler_Address_Mode::ClampToZero, RHI_Comparison_Function::Greater, 0.0f, true,  0.0f); // reverse-z
                sampler(Renderer_Sampler::Point_clamp_edge,      RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Sampler_Address_Mode::Clamp,       RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Point_clamp_border,    RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Sampler_Address_Mode::ClampToZero, RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Point_wrap,            RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Filter::Nearest, RHI_Sampler_Address_Mode::Wrap,        RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Bilinear_clamp_edge,   RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Filter::Nearest, RHI_Sampler_Address_Mode::Clamp,       RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Bilinear_clamp_border, RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Filter::Nearest, RHI_Sampler_Address_Mode::ClampToZero, RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Bilinear_wrap,         RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Filter::Nearest, RHI_Sampler_Address_Mode::Wrap,        RHI_Comparison_Function::Never,   0.0f, false, 0.0f);
                sampler(Renderer_Sampler::Trilinear_clamp,       RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Filter::Linear,  RHI_Sampler_Address_Mode::Clamp,       RHI_Comparison_Function::Never,   0.0f, false, 0.0f);

                samplers_created = true;
            }
        }

        // anisotropic (negative mip bias when upscaling to keep textures sharp)
        {
            float mip_bias_new = 0.0f;
            if (GetResolutionOutput().x > GetResolutionRender().x)
            {
                mip_bias_new = log2(GetResolutionRender().x / GetResolutionOutput().x) - 1.0f;
            }

            static float mip_bias = numeric_limits<float>::max();
            if (mip_bias_new != mip_bias)
            {
                mip_bias         = mip_bias_new;
                float anisotropy = cvar_anisotropy.GetValue();
                sampler(Renderer_Sampler::Anisotropic_wrap, RHI_Filter::Linear, RHI_Filter::Linear, RHI_Filter::Linear, RHI_Sampler_Address_Mode::Wrap, RHI_Comparison_Function::Always, anisotropy, false, mip_bias);
            }
        }

        m_bindless_samplers_dirty = true;
    }

    void Renderer::UpdateOptionalRenderTargets()
    {
        uint32_t width  = static_cast<uint32_t>(GetResolutionRender().x);
        uint32_t height = static_cast<uint32_t>(GetResolutionRender().y);
        uint32_t flags  = RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit;

        #define render_target(x) render_targets[static_cast<uint8_t>(x)]
        
        // ssao
        bool need_ssao = cvar_ssao.GetValueAs<bool>();
        if (need_ssao && !render_target(Renderer_RenderTarget::ssao))
        {
            render_target(Renderer_RenderTarget::ssao) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, flags | RHI_Texture_ConcurrentSharing, "ssao");
        }
        else if (!need_ssao && render_target(Renderer_RenderTarget::ssao))
        {
            render_target(Renderer_RenderTarget::ssao) = nullptr;
        }
        
        // ray traced reflections gbuffer
        bool need_rt_reflections = cvar_ray_traced_reflections.GetValueAs<bool>() && RHI_Device::IsSupportedRayTracing();
        if (need_rt_reflections && !render_target(Renderer_RenderTarget::gbuffer_reflections_position))
        {
            render_target(Renderer_RenderTarget::gbuffer_reflections_position) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R32G32B32A32_Float, flags, "gbuffer_reflections_position");
            render_target(Renderer_RenderTarget::gbuffer_reflections_normal)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, flags, "gbuffer_reflections_normal");
            render_target(Renderer_RenderTarget::gbuffer_reflections_albedo)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R8G8B8A8_Unorm,     flags, "gbuffer_reflections_albedo");
        }
        else if (!need_rt_reflections && render_target(Renderer_RenderTarget::gbuffer_reflections_position))
        {
            render_target(Renderer_RenderTarget::gbuffer_reflections_position) = nullptr;
            render_target(Renderer_RenderTarget::gbuffer_reflections_normal)   = nullptr;
            render_target(Renderer_RenderTarget::gbuffer_reflections_albedo)   = nullptr;
        }
        
        // restir reservoirs
        bool need_restir = cvar_restir_pt.GetValueAs<bool>() && RHI_Device::IsSupportedRayTracing();
        if (need_restir && !render_target(Renderer_RenderTarget::restir_reservoir0))
        {
            uint32_t restir_flags = flags | RHI_Texture_ConcurrentSharing;

            static const char* reservoir_names[] =
            {
                "restir_reservoir0",         "restir_reservoir1",         "restir_reservoir2",         "restir_reservoir3",         "restir_reservoir4",
                "restir_reservoir_prev0",    "restir_reservoir_prev1",    "restir_reservoir_prev2",    "restir_reservoir_prev3",    "restir_reservoir_prev4",
                "restir_reservoir_spatial0", "restir_reservoir_spatial1", "restir_reservoir_spatial2", "restir_reservoir_spatial3", "restir_reservoir_spatial4",
            };

            for (uint32_t i = 0; i < 15; i++)
            {
                auto rt = static_cast<Renderer_RenderTarget>(static_cast<uint32_t>(Renderer_RenderTarget::restir_reservoir0) + i);
                render_target(rt) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R32G32B32A32_Float, restir_flags, reservoir_names[i]);
            }
            
            // nrd denoiser
            render_target(Renderer_RenderTarget::nrd_viewz)                    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16_Float,          restir_flags, "nrd_viewz");
            render_target(Renderer_RenderTarget::nrd_normal_roughness)         = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R10G10B10A2_Unorm,  restir_flags, "nrd_normal_roughness");
            render_target(Renderer_RenderTarget::nrd_diff_radiance_hitdist)    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, restir_flags, "nrd_diff_radiance_hitdist");
            render_target(Renderer_RenderTarget::nrd_spec_radiance_hitdist)    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, restir_flags, "nrd_spec_radiance_hitdist");
            render_target(Renderer_RenderTarget::nrd_out_diff_radiance_hitdist)= make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, restir_flags, "nrd_out_diff_radiance_hitdist");
            render_target(Renderer_RenderTarget::nrd_out_spec_radiance_hitdist)= make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width, height, 1, 1, RHI_Format::R16G16B16A16_Float, restir_flags, "nrd_out_spec_radiance_hitdist");
        }
        else if (!need_restir && render_target(Renderer_RenderTarget::restir_reservoir0))
        {
            for (uint32_t i = 0; i < 15; i++)
            {
                auto rt = static_cast<Renderer_RenderTarget>(static_cast<uint32_t>(Renderer_RenderTarget::restir_reservoir0) + i);
                render_target(rt) = nullptr;
            }
            
            render_target(Renderer_RenderTarget::nrd_viewz)                     = nullptr;
            render_target(Renderer_RenderTarget::nrd_normal_roughness)          = nullptr;
            render_target(Renderer_RenderTarget::nrd_diff_radiance_hitdist)     = nullptr;
            render_target(Renderer_RenderTarget::nrd_spec_radiance_hitdist)     = nullptr;
            render_target(Renderer_RenderTarget::nrd_out_diff_radiance_hitdist) = nullptr;
            render_target(Renderer_RenderTarget::nrd_out_spec_radiance_hitdist) = nullptr;
        }
        
        #undef render_target
    }

    void Renderer::CreateRenderTargets(const bool create_render, const bool create_output, const bool create_dynamic)
    {
        uint32_t width_render  = static_cast<uint32_t>(GetResolutionRender().x);
        uint32_t height_render = static_cast<uint32_t>(GetResolutionRender().y);
        uint32_t width_output  = static_cast<uint32_t>(GetResolutionOutput().x);
        uint32_t height_output = static_cast<uint32_t>(GetResolutionOutput().y);

        auto compute_mip_count = [](const uint32_t width, const uint32_t height, const uint32_t smallest_dimension)
        {
            uint32_t max_dimension = max(width, height);
            uint32_t mip_count     = 1;
            while (max_dimension >= smallest_dimension)
            {
                max_dimension /= 2;
                mip_count++;
            }
            return mip_count;
        };

        // avoid combining uav + rtv on frequently accessed targets (forces suboptimal layouts on amd)

        #define render_target(x) render_targets[static_cast<uint8_t>(x)]
        // resolution - render
        if (create_render)
        {
            // frame
            {
                render_target(Renderer_RenderTarget::frame_render)        = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit, "frame_render");
                render_target(Renderer_RenderTarget::frame_render_opaque) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit, "frame_render_opaque");
            }

            // g-buffer (concurrent sharing: read by async compute for ssao/sss)
            {
                uint32_t flags = RHI_Texture_Rtv | RHI_Texture_Srv | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing;

                render_target(Renderer_RenderTarget::gbuffer_color)    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R8G8B8A8_Unorm,     flags, "gbuffer_color");
                render_target(Renderer_RenderTarget::gbuffer_normal)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R16G16B16A16_Float, flags, "gbuffer_normal");
                render_target(Renderer_RenderTarget::gbuffer_material) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R8G8B8A8_Unorm,     flags, "gbuffer_material");
                render_target(Renderer_RenderTarget::gbuffer_velocity) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R16G16_Float,       flags, "gbuffer_velocity");
                render_target(Renderer_RenderTarget::gbuffer_depth)    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::D32_Float,          flags, "gbuffer_depth");
            }

            // light
            {
                uint32_t flags = RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit;

                render_target(Renderer_RenderTarget::light_diffuse)    = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R11G11B10_Float, flags, "light_diffuse");
                render_target(Renderer_RenderTarget::light_specular)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R11G11B10_Float, flags, "light_specular");
                render_target(Renderer_RenderTarget::light_volumetric) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::R11G11B10_Float, flags, "light_volumetric");
            }

            // occlusion
            {
                // amd depth format restrictions: separate texture for uav + manual blit
                render_target(Renderer_RenderTarget::gbuffer_depth_occluders) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, 1, RHI_Format::D32_Float, RHI_Texture_Rtv | RHI_Texture_Srv, "depth_occluders");

                // full mip chain so the cull shader can pick a level where the aabb fits in ~1-2 texels
                uint32_t hiz_mip_count = static_cast<uint32_t>(floor(log2(static_cast<float>(max(width_render, height_render))))) + 1;
                render_target(Renderer_RenderTarget::gbuffer_depth_occluders_hiz) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_render, height_render, 1, hiz_mip_count, RHI_Format::R32_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit | RHI_Texture_PerMipViews, "depth_occluders_hiz");
            }

            // misc
            render_target(Renderer_RenderTarget::sss)                = make_shared<RHI_Texture>(RHI_Texture_Type::Type2DArray, width_render, height_render, 4, 1, RHI_Format::R16_Float,          RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing, "sss");
            render_target(Renderer_RenderTarget::reflections)        = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D,      width_render, height_render, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit, "reflections");
            render_target(Renderer_RenderTarget::ray_traced_shadows) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D,      width_render, height_render, 1, 1, RHI_Format::R16_Float,          RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing, "ray_traced_shadows");
            render_target(Renderer_RenderTarget::restir_output)      = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D,      width_render, height_render, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing, "restir_output");
            
            // optional render targets (ssao, rt reflections, restir)
            UpdateOptionalRenderTargets();
            
            if (RHI_Device::IsSupportedVrs())
            {
                // vrs texture dimensions must match the gpu's reported texel size
                uint32_t texel_size_x = max(RHI_Device::PropertyGetMaxShadingRateTexelSizeX(), 1u);
                uint32_t texel_size_y = max(RHI_Device::PropertyGetMaxShadingRateTexelSizeY(), 1u);
                uint32_t vrs_width    = (width_render + texel_size_x - 1) / texel_size_x;
                uint32_t vrs_height   = (height_render + texel_size_y - 1) / texel_size_y;
                render_target(Renderer_RenderTarget::shading_rate) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, vrs_width, vrs_height, 1, 1, RHI_Format::R8_Uint, RHI_Texture_Srv | RHI_Texture_Uav | RHI_Texture_Rtv | RHI_Texture_Vrs | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing, "shading_rate");
            }
            render_target(Renderer_RenderTarget::shadow_atlas) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 8192, 8192, 1, 1, RHI_Format::D32_Float, RHI_Texture_Rtv | RHI_Texture_Srv | RHI_Texture_ClearBlit, "shadow_atlas");
        }

        // resolution - output
        if (create_output)
        {
            // frame
            uint32_t mip_count = compute_mip_count(width_output, height_output, 16);
            render_target(Renderer_RenderTarget::frame_output)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, mip_count, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit | RHI_Texture_PerMipViews | RHI_Texture_ConcurrentSharing, "frame_output");
            render_target(Renderer_RenderTarget::frame_output_2) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit, "frame_output_2");
            render_target(Renderer_RenderTarget::debug_output)   = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit, "debug_output");

            // misc
            render_target(Renderer_RenderTarget::bloom)                       = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, mip_count, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_PerMipViews, "bloom");
            render_target(Renderer_RenderTarget::outline)                     = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, 1,         RHI_Format::R8G8B8A8_Unorm,     RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_Rtv,         "outline");
            render_target(Renderer_RenderTarget::gbuffer_depth_opaque_output) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, width_output, height_output, 1, 1,         RHI_Format::D32_Float,          RHI_Texture_Srv | RHI_Texture_Rtv | RHI_Texture_ClearBlit,   "depth_opaque_output");
        }

        // resolution - fixed (created once)
        if (!render_target(Renderer_RenderTarget::lut_brdf_specular))
        {
            // lookup tables
            render_target(Renderer_RenderTarget::lut_brdf_specular)           = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 512, 512,  1, 1, RHI_Format::R16G16_Float, RHI_Texture_Uav | RHI_Texture_Srv, "lut_brdf_specular");
            render_target(Renderer_RenderTarget::lut_atmosphere_scatter)      = make_shared<RHI_Texture>(RHI_Texture_Type::Type3D, 256, 256, 32, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv, "lut_atmosphere_scatter");
            render_target(Renderer_RenderTarget::lut_atmosphere_transmittance)= make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 256, 64,   1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv, "lut_atmosphere_transmittance");
            render_target(Renderer_RenderTarget::lut_atmosphere_multiscatter) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 32,  32,   1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv, "lut_atmosphere_multiscatter");

            // misc
            render_target(Renderer_RenderTarget::blur)      = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 4096, 4096, 1, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv, "blur_scratch");
            const uint32_t lowest_dimension                 = 16; // lowest mip is 16x16, preserving directional detail for diffuse IBL (1x1 loses directionality)
            render_target(Renderer_RenderTarget::skysphere) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 4096, 2048, 1, compute_mip_count(4096, 2048, lowest_dimension), RHI_Format::R11G11B10_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_PerMipViews | RHI_Texture_ClearBlit | RHI_Texture_ConcurrentSharing, "skysphere");

            // auto-exposure
            render_target(Renderer_RenderTarget::auto_exposure)          = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 1, 1, 1, 1, RHI_Format::R32_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit, "auto_exposure_1");
            render_target(Renderer_RenderTarget::auto_exposure_previous) = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 1, 1, 1, 1, RHI_Format::R32_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ClearBlit, "auto_exposure_2");

            // volumetric clouds (r16g16b16a16 to avoid material texture detection)
            render_target(Renderer_RenderTarget::cloud_noise_shape)  = make_shared<RHI_Texture>(RHI_Texture_Type::Type3D, 128, 128, 128, 1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ConcurrentSharing, "cloud_noise_shape");
            render_target(Renderer_RenderTarget::cloud_noise_detail) = make_shared<RHI_Texture>(RHI_Texture_Type::Type3D, 32,  32,  32,  1, RHI_Format::R16G16B16A16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ConcurrentSharing, "cloud_noise_detail");
            render_target(Renderer_RenderTarget::cloud_shadow)       = make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 1024, 1024, 1, 1, RHI_Format::R16_Float, RHI_Texture_Uav | RHI_Texture_Srv | RHI_Texture_ConcurrentSharing, "cloud_shadow");
            
        }
    }

    void Renderer::CreateShaders()
    {
        const bool async        = true;
        const string shader_dir = ResourceCache::GetResourceDirectory(ResourceDirectory::Shaders) + "/";
        #define shader(x) shaders[static_cast<uint8_t>(x)]

        // debug
        {
            // line
            shader(Renderer_Shader::line_v) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::line_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "line.hlsl", async, RHI_Vertex_Type::PosCol);
            shader(Renderer_Shader::line_p) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::line_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "line.hlsl", async);

            // grid
            {
                shader(Renderer_Shader::grid_v) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::grid_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "grid.hlsl", async, RHI_Vertex_Type::PosUvNorTan);

                shader(Renderer_Shader::grid_p) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::grid_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "grid.hlsl", async);
            }

            // outline
            {
                shader(Renderer_Shader::outline_v) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::outline_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "outline.hlsl", async, RHI_Vertex_Type::PosUvNorTan);

                shader(Renderer_Shader::outline_p) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::outline_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "outline.hlsl", async);

                shader(Renderer_Shader::outline_c) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::outline_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "outline.hlsl", async);
            }
        }

        // depth
        {
            shader(Renderer_Shader::depth_prepass_v) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::depth_prepass_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "depth_prepass.hlsl", async, RHI_Vertex_Type::PosUvNorTan);

            shader(Renderer_Shader::depth_prepass_alpha_test_p) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::depth_prepass_alpha_test_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "depth_prepass.hlsl", async);
        }

        // light depth
        {
            shader(Renderer_Shader::depth_light_v) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::depth_light_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "depth_light.hlsl", async, RHI_Vertex_Type::PosUvNorTan);

            shader(Renderer_Shader::depth_light_alpha_color_p) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::depth_light_alpha_color_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "depth_light.hlsl", async);
        }

        // g-buffer
        {
            shader(Renderer_Shader::gbuffer_v) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::gbuffer_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "g_buffer.hlsl", async, RHI_Vertex_Type::PosUvNorTan);

            shader(Renderer_Shader::gbuffer_p) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::gbuffer_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "g_buffer.hlsl", async);
        }

        // tessellation
        {
            shader(Renderer_Shader::tessellation_h) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::tessellation_h)->Compile(RHI_Shader_Type::Hull, shader_dir + "common_tessellation.hlsl", async);

            shader(Renderer_Shader::tessellation_d) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::tessellation_d)->Compile(RHI_Shader_Type::Domain, shader_dir + "common_tessellation.hlsl", async);
        }

        // light
        {
            // brdf specular lut - compile synchronously as it's needed immediately
            shader(Renderer_Shader::light_integration_brdf_specular_lut_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_integration_brdf_specular_lut_c)->AddDefine("BRDF_SPECULAR_LUT");
            shader(Renderer_Shader::light_integration_brdf_specular_lut_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light_integration.hlsl", false);

            // environment prefilter - compile synchronously as it's needed immediately
            shader(Renderer_Shader::light_integration_environment_filter_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_integration_environment_filter_c)->AddDefine("ENVIRONMENT_FILTER");
            shader(Renderer_Shader::light_integration_environment_filter_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light_integration.hlsl", async);

            // light
            shader(Renderer_Shader::light_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light.hlsl", async);

            // composition
            shader(Renderer_Shader::light_composition_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_composition_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light_composition.hlsl", async);

            // image based
            shader(Renderer_Shader::light_image_based_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_image_based_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light_image_based.hlsl", async);
        }

        // blur
        {
            // gaussian
            shader(Renderer_Shader::blur_gaussian_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::blur_gaussian_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "blur.hlsl", async);

            // gaussian bilateral - or depth aware
            shader(Renderer_Shader::blur_gaussian_bilaterial_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::blur_gaussian_bilaterial_c)->AddDefine("PASS_BLUR_GAUSSIAN_BILATERAL");
            shader(Renderer_Shader::blur_gaussian_bilaterial_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "blur.hlsl", async);
        }

        // bloom
        {
            // downsample luminance
            shader(Renderer_Shader::bloom_luminance_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::bloom_luminance_c)->AddDefine("LUMINANCE");
            shader(Renderer_Shader::bloom_luminance_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "bloom.hlsl", async);

            // downsample (stable 13-tap)
            shader(Renderer_Shader::bloom_downsample_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::bloom_downsample_c)->AddDefine("DOWNSAMPLE");
            shader(Renderer_Shader::bloom_downsample_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "bloom.hlsl", async);

            // upsample blend (with previous mip)
            shader(Renderer_Shader::bloom_upsample_blend_mip_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::bloom_upsample_blend_mip_c)->AddDefine("UPSAMPLE_BLEND_MIP");
            shader(Renderer_Shader::bloom_upsample_blend_mip_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "bloom.hlsl", async);

            // upsample blend (with frame)
            shader(Renderer_Shader::bloom_blend_frame_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::bloom_blend_frame_c)->AddDefine("BLEND_FRAME");
            shader(Renderer_Shader::bloom_blend_frame_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "bloom.hlsl", async);
        }

        // amd fidelityfx
        {
            // cas - contrast adaptive sharpening
            shader(Renderer_Shader::ffx_cas_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::ffx_cas_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "amd_fidelity_fx/cas.hlsl", async);

            // spd - single pass downsample - compile synchronously as they are needed everywhere
            {
                shader(Renderer_Shader::ffx_spd_average_c) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::ffx_spd_average_c)->AddDefine("AVERAGE");
                shader(Renderer_Shader::ffx_spd_average_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "amd_fidelity_fx/spd.hlsl", false);

                shader(Renderer_Shader::ffx_spd_min_c) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::ffx_spd_min_c)->AddDefine("MIN");
                shader(Renderer_Shader::ffx_spd_min_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "amd_fidelity_fx/spd.hlsl", false);

                shader(Renderer_Shader::ffx_spd_max_c) = make_shared<RHI_Shader>();
                shader(Renderer_Shader::ffx_spd_max_c)->AddDefine("MAX");
                shader(Renderer_Shader::ffx_spd_max_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "amd_fidelity_fx/spd.hlsl", false);
            }
        }

        // sky
        {
            shader(Renderer_Shader::skysphere_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::skysphere_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/skysphere.hlsl", async);

            shader(Renderer_Shader::skysphere_lut_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::skysphere_lut_c)->AddDefine("LUT");
            shader(Renderer_Shader::skysphere_lut_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/skysphere.hlsl", async);

            // transmittance lut - precomputes optical depth to atmosphere top
            shader(Renderer_Shader::skysphere_transmittance_lut_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::skysphere_transmittance_lut_c)->AddDefine("TRANSMITTANCE_LUT");
            shader(Renderer_Shader::skysphere_transmittance_lut_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/skysphere.hlsl", false); // sync - needed by multiscatter

            // multi-scatter lut - approximates infinite bounce scattering
            shader(Renderer_Shader::skysphere_multiscatter_lut_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::skysphere_multiscatter_lut_c)->AddDefine("MULTISCATTER_LUT");
            shader(Renderer_Shader::skysphere_multiscatter_lut_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/skysphere.hlsl", false); // sync - needed by main pass
        }

        // fxaa
        shader(Renderer_Shader::fxaa_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::fxaa_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "fxaa/fxaa.hlsl", async);

        // font
        shader(Renderer_Shader::font_v) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::font_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "font.hlsl", async, RHI_Vertex_Type::PosUv);
        shader(Renderer_Shader::font_p) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::font_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "font.hlsl", async);

        // film grain
        shader(Renderer_Shader::film_grain_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::film_grain_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "film_grain.hlsl", async);

        // chromatic aberration
        shader(Renderer_Shader::chromatic_aberration_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::chromatic_aberration_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "chromatic_aberration.hlsl", async);

        // vhs
        shader(Renderer_Shader::vhs_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::vhs_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "vhs.hlsl", async);

        // tone-mapping & gamma correction
        shader(Renderer_Shader::output_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::output_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "output.hlsl", async);

        // motion blur
        shader(Renderer_Shader::motion_blur_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::motion_blur_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "motion_blur.hlsl", async);

        // screen space global illumination
        shader(Renderer_Shader::ssao_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::ssao_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "ssao.hlsl", async);

        // screen space shadows
        shader(Renderer_Shader::sss_c_bend) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::sss_c_bend)->Compile(RHI_Shader_Type::Compute, shader_dir + "screen_space_shadows/bend_sss.hlsl", async);

        // depth of field
        shader(Renderer_Shader::depth_of_field_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::depth_of_field_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "depth_of_field.hlsl", async);

        // variable rate shading
        shader(Renderer_Shader::variable_rate_shading_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::variable_rate_shading_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "variable_rate_shading.hlsl", async);

        // blit
        shader(Renderer_Shader::blit_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::blit_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "blit.hlsl", async);

        // indirect draw culling
        shader(Renderer_Shader::indirect_cull_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::indirect_cull_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "indirect_cull.hlsl", async);

        // indirect draw g-buffer variants (vertex pulling, no input assembly)
        shader(Renderer_Shader::gbuffer_indirect_v) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::gbuffer_indirect_v)->AddDefine("INDIRECT_DRAW");
        shader(Renderer_Shader::gbuffer_indirect_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "g_buffer.hlsl", async, RHI_Vertex_Type::Max);

        shader(Renderer_Shader::gbuffer_indirect_p) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::gbuffer_indirect_p)->AddDefine("INDIRECT_DRAW");
        shader(Renderer_Shader::gbuffer_indirect_p)->Compile(RHI_Shader_Type::Pixel, shader_dir + "g_buffer.hlsl", async);

        // indirect draw depth prepass variant (vertex pulling, no input assembly)
        shader(Renderer_Shader::depth_prepass_indirect_v) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::depth_prepass_indirect_v)->AddDefine("INDIRECT_DRAW");
        shader(Renderer_Shader::depth_prepass_indirect_v)->Compile(RHI_Shader_Type::Vertex, shader_dir + "depth_prepass.hlsl", async, RHI_Vertex_Type::Max);

        // icon
        shader(Renderer_Shader::icon_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::icon_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "icon.hlsl", async);

        // dithering
        shader(Renderer_Shader::dithering_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::dithering_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "dithering.hlsl", async);

        // reflection, refraction & transparency
        shader(Renderer_Shader::transparency_reflection_refraction_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::transparency_reflection_refraction_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "transparency_reflection_refraction.hlsl", async);

        // auto-exposure
        shader(Renderer_Shader::auto_exposure_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::auto_exposure_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "auto_exposure.hlsl", async);

        // ray-tracing
        if (RHI_Device::IsSupportedRayTracing())
        {
            // ray generation
            shader(Renderer_Shader::reflections_ray_generation_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::reflections_ray_generation_r)->Compile(RHI_Shader_Type::RayGeneration, shader_dir + "ray_traced_reflections.hlsl", async);
        
            // ray miss
            shader(Renderer_Shader::reflections_ray_miss_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::reflections_ray_miss_r)->Compile(RHI_Shader_Type::RayMiss, shader_dir + "ray_traced_reflections.hlsl", async);
        
            // ray hit
            shader(Renderer_Shader::reflections_ray_hit_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::reflections_ray_hit_r)->Compile(RHI_Shader_Type::RayHit, shader_dir + "ray_traced_reflections.hlsl", async);
            
            // deferred shading for reflection hits
            shader(Renderer_Shader::light_reflections_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::light_reflections_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "light_reflections.hlsl", async);
            
            // nrd input preparation
            shader(Renderer_Shader::nrd_prepare_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::nrd_prepare_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "nrd_prepare.hlsl", async);
            
            // ray traced shadows
            shader(Renderer_Shader::shadows_ray_generation_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::shadows_ray_generation_r)->Compile(RHI_Shader_Type::RayGeneration, shader_dir + "ray_traced_shadows.hlsl", async);
            
            shader(Renderer_Shader::shadows_ray_miss_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::shadows_ray_miss_r)->Compile(RHI_Shader_Type::RayMiss, shader_dir + "ray_traced_shadows.hlsl", async);
            
            shader(Renderer_Shader::shadows_ray_hit_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::shadows_ray_hit_r)->Compile(RHI_Shader_Type::RayHit, shader_dir + "ray_traced_shadows.hlsl", async);
            
            // restir gi
            shader(Renderer_Shader::restir_pt_ray_generation_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::restir_pt_ray_generation_r)->Compile(RHI_Shader_Type::RayGeneration, shader_dir + "restir_pt.hlsl", async);
            
            shader(Renderer_Shader::restir_pt_ray_miss_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::restir_pt_ray_miss_r)->AddDefine("MAIN_MISS");
            shader(Renderer_Shader::restir_pt_ray_miss_r)->Compile(RHI_Shader_Type::RayMiss, shader_dir + "restir_pt.hlsl", async);
            
            shader(Renderer_Shader::restir_pt_ray_hit_r) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::restir_pt_ray_hit_r)->AddDefine("MAIN_HIT");
            shader(Renderer_Shader::restir_pt_ray_hit_r)->Compile(RHI_Shader_Type::RayHit, shader_dir + "restir_pt.hlsl", async);
            
            // restir resampling
            shader(Renderer_Shader::restir_pt_temporal_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::restir_pt_temporal_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "restir_pt_temporal.hlsl", async);
            
            shader(Renderer_Shader::restir_pt_spatial_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::restir_pt_spatial_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "restir_pt_spatial.hlsl", async);
        }

        // volumetric clouds
        {
            shader(Renderer_Shader::cloud_noise_shape_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::cloud_noise_shape_c)->AddDefine("SHAPE_NOISE");
            shader(Renderer_Shader::cloud_noise_shape_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/cloud_noise.hlsl", async);

            shader(Renderer_Shader::cloud_noise_detail_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::cloud_noise_detail_c)->AddDefine("DETAIL_NOISE");
            shader(Renderer_Shader::cloud_noise_detail_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/cloud_noise.hlsl", async);

            shader(Renderer_Shader::cloud_shadow_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::cloud_shadow_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "sky/cloud_shadow.hlsl", async);

        }

        // gpu-driven particles
        {
            shader(Renderer_Shader::particle_emit_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::particle_emit_c)->AddDefine("EMIT");
            shader(Renderer_Shader::particle_emit_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "particles.hlsl", async);

            shader(Renderer_Shader::particle_simulate_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::particle_simulate_c)->AddDefine("SIMULATE");
            shader(Renderer_Shader::particle_simulate_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "particles.hlsl", async);

            shader(Renderer_Shader::particle_render_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::particle_render_c)->AddDefine("RENDER");
            shader(Renderer_Shader::particle_render_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "particles.hlsl", async);
        }

        // gpu skinning
        {
            shader(Renderer_Shader::skinning_c) = make_shared<RHI_Shader>();
            shader(Renderer_Shader::skinning_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "gpu_skinning.hlsl", async);
        }

        // gpu texture compression - compiled synchronously since it's needed during texture loading
        shader(Renderer_Shader::texture_compress_bc1_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::texture_compress_bc1_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "texture_compress_bc1.hlsl", false);
        shader(Renderer_Shader::texture_compress_bc3_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::texture_compress_bc3_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "texture_compress_bc3.hlsl", false);
        shader(Renderer_Shader::texture_compress_bc5_c) = make_shared<RHI_Shader>();
        shader(Renderer_Shader::texture_compress_bc5_c)->Compile(RHI_Shader_Type::Compute, shader_dir + "texture_compress_bc5.hlsl", false);

    }

    void Renderer::CreateFonts()
    {
        const string dir_font = ResourceCache::GetResourceDirectory(ResourceDirectory::Fonts) + "/";

        uint32_t size = static_cast<uint32_t>(10 * Window::GetDpiScale());
        standard_font = make_shared<Font>(dir_font + "OpenSans/OpenSans-Medium.ttf", size, Color(0.9f, 0.9f, 0.9f, 1.0f));
    }

    void Renderer::CreateStandardMeshes()
    {
        using VertexVec = vector<RHI_Vertex_PosTexNorTan>;
        using IndexVec  = vector<uint32_t>;

        struct MeshDef
        {
            MeshType type;
            void (*generate)(VertexVec*, IndexVec*);
            const char* name;
        };

        // wrappers to bind default arguments for functions with extra parameters
        auto gen_sphere   = [](VertexVec* v, IndexVec* i) { geometry_generation::generate_sphere(v, i);   };
        auto gen_cylinder = [](VertexVec* v, IndexVec* i) { geometry_generation::generate_cylinder(v, i); };
        auto gen_cone     = [](VertexVec* v, IndexVec* i) { geometry_generation::generate_cone(v, i);     };

        const MeshDef defs[] =
        {
            { MeshType::Cube,     geometry_generation::generate_cube, "standard_cube"     },
            { MeshType::Quad,     geometry_generation::generate_quad, "standard_quad"     },
            { MeshType::Sphere,   +gen_sphere,                        "standard_sphere"   },
            { MeshType::Cylinder, +gen_cylinder,                      "standard_cylinder" },
            { MeshType::Cone,     +gen_cone,                          "standard_cone"     },
        };

        const string project_directory = ResourceCache::GetProjectDirectory();
        for (const MeshDef& def : defs)
        {
            shared_ptr<Mesh> mesh = make_shared<Mesh>();
            VertexVec vertices;
            IndexVec indices;

            def.generate(&vertices, &indices);
            mesh->SetResourceFilePath(project_directory + def.name + EXTENSION_MESH);
            mesh->SetFlag(static_cast<uint32_t>(MeshFlags::PostProcessOptimize), false);
            mesh->AddGeometry(vertices, indices, false);
            mesh->SetType(def.type);
            mesh->CreateGpuBuffers();

            standard_meshes[static_cast<uint8_t>(def.type)] = mesh;
        }

        m_lines_vertex_buffer = make_shared<RHI_Buffer>();
    }

    void Renderer::CreateStandardTextures()
    {
        const string dir_texture   = ResourceCache::GetResourceDirectory(ResourceDirectory::Textures) + "/";
        const string dir_materials = "project/materials/";

        #define standard_texture(x) standard_textures[static_cast<uint32_t>(x)]

        // perlin noise
        standard_texture(Renderer_StandardTexture::Noise_perlin) = make_shared<RHI_Texture>(dir_texture + "noise_perlin.png");

        // blue noise texture (only one is actually used in shaders)
        standard_texture(Renderer_StandardTexture::Noise_blue) = make_shared<RHI_Texture>(dir_texture + "noise_blue_0.png");

        // gizmos
        {
            standard_texture(Renderer_StandardTexture::Gizmo_light_directional) = make_shared<RHI_Texture>(dir_texture + "sun.png");
            standard_texture(Renderer_StandardTexture::Gizmo_light_point)       = make_shared<RHI_Texture>(dir_texture + "light_bulb.png");
            standard_texture(Renderer_StandardTexture::Gizmo_light_spot)        = make_shared<RHI_Texture>(dir_texture + "flashlight.png");
            standard_texture(Renderer_StandardTexture::Gizmo_audio_source)      = make_shared<RHI_Texture>(dir_texture + "audio.png");
        }

        // misc
        {
            standard_texture(Renderer_StandardTexture::Checkerboard) = make_shared<RHI_Texture>(dir_texture + "no_texture.png");
        }

        // solid 1x1 textures
        {
            auto create_solid_texture = [](const char* name, std::byte r, std::byte g, std::byte b, std::byte a)
            {
                std::vector<RHI_Texture_Mip>   mips   = { RHI_Texture_Mip{std::vector<std::byte>{r, g, b, a}} };
                std::vector<RHI_Texture_Slice> slices  = { RHI_Texture_Slice{mips} };
                return make_shared<RHI_Texture>(RHI_Texture_Type::Type2D, 1, 1, 1, 1, RHI_Format::R8G8B8A8_Unorm, RHI_Texture_Srv | RHI_Texture_Uav, name, slices);
            };

            standard_texture(Renderer_StandardTexture::Black) = create_solid_texture("black_texture", std::byte{0},   std::byte{0},   std::byte{0},   std::byte{255});
            standard_texture(Renderer_StandardTexture::White) = create_solid_texture("white_texture", std::byte{255}, std::byte{255}, std::byte{255}, std::byte{255});
        }
    }

    void Renderer::CreateStandardMaterials()
    {
        const string data_dir = string(ResourceCache::GetDataDirectory()) + "/";
        FileSystem::CreateDirectory_(data_dir);

        standard_material = make_shared<Material>();
        standard_material->SetResourceName("standard" + string(EXTENSION_MATERIAL));
        standard_material->SetProperty(MaterialProperty::TextureTilingX, 1.0f);
        standard_material->SetProperty(MaterialProperty::TextureTilingY, 1.0f);
        standard_material->SetProperty(MaterialProperty::ColorR,         1.0f);
        standard_material->SetProperty(MaterialProperty::ColorG,         1.0f);
        standard_material->SetProperty(MaterialProperty::ColorB,         1.0f);
        standard_material->SetProperty(MaterialProperty::ColorA,         1.0f);
        standard_material->SetProperty(MaterialProperty::WorldSpaceUv,   1.0f);
        standard_material->SetTexture(MaterialTextureType::Color,        Renderer::GetStandardTexture(Renderer_StandardTexture::Checkerboard));
    }

    void Renderer::DestroyResources()
    {
        render_targets.fill(nullptr);
        shaders.fill(nullptr);
        samplers.fill(nullptr);
        standard_textures.fill(nullptr);
        standard_meshes.fill(nullptr);
        buffers.fill(nullptr);

        m_frame_resources.fill(FrameResource{});

        standard_font     = nullptr;
        standard_material = nullptr;
    }

    array<shared_ptr<RHI_Texture>, static_cast<uint32_t>(Renderer_RenderTarget::max)>& Renderer::GetRenderTargets()
    {
        return render_targets;
    }

    array<shared_ptr<RHI_Shader>, static_cast<uint32_t>(Renderer_Shader::max)>& Renderer::GetShaders()
    {
        return shaders;
    }

    array<shared_ptr<RHI_Buffer>, static_cast<uint32_t>(Renderer_Buffer::Max)>& Renderer::GetStructuredBuffers()
    {
        return buffers;
    }

    array<shared_ptr<RHI_Sampler>, static_cast<uint32_t>(Renderer_Sampler::Max)>& Renderer::GetSamplers()
    {
        return samplers;
    }

    RHI_RasterizerState* Renderer::GetRasterizerState(const Renderer_RasterizerState type)
    {
        return rasterizer_states[static_cast<uint8_t>(type)].get();
    }

    RHI_DepthStencilState* Renderer::GetDepthStencilState(const Renderer_DepthStencilState type)
    {
        return depth_stencil_states[static_cast<uint8_t>(type)].get();
    }

    RHI_BlendState* Renderer::GetBlendState(const Renderer_BlendState type)
    {
        return blend_states[static_cast<uint8_t>(type)].get();
    }

    RHI_Texture* Renderer::GetRenderTarget(const Renderer_RenderTarget type)
    {
        return render_targets[static_cast<uint8_t>(type)].get();
    }

    RHI_Shader* Renderer::GetShader(const Renderer_Shader type)
    {
        return shaders[static_cast<uint8_t>(type)].get();
    }

    RHI_Buffer* Renderer::GetBuffer(const Renderer_Buffer type)
    {
        // Static skinning buffers are managed by SkinningGeometryBuffer
        switch (type)
        {
            case Renderer_Buffer::SkinningVerticesIn:  return SkinningGeometryBuffer::GetVerticesBuffer();
            case Renderer_Buffer::SkinningIndices:     return SkinningGeometryBuffer::GetIndicesBuffer();
            case Renderer_Buffer::SkinningWeights:     return SkinningGeometryBuffer::GetWeightsBuffer();
            default: break;
        }
        return buffers[static_cast<uint8_t>(type)].get();
    }

    void Renderer::RotateFrameBuffers()
    {
        m_frame_resource_index = (m_frame_resource_index + 1) % renderer_draw_data_buffer_count;
        const FrameResource& fr = m_frame_resources[m_frame_resource_index];

        buffers[static_cast<uint8_t>(Renderer_Buffer::IndirectDrawArgs)]    = fr.indirect_draw_args;
        buffers[static_cast<uint8_t>(Renderer_Buffer::IndirectDrawData)]    = fr.indirect_draw_data;
        buffers[static_cast<uint8_t>(Renderer_Buffer::IndirectDrawArgsOut)] = fr.indirect_draw_args_out;
        buffers[static_cast<uint8_t>(Renderer_Buffer::IndirectDrawDataOut)] = fr.indirect_draw_data_out;
        buffers[static_cast<uint8_t>(Renderer_Buffer::IndirectDrawCount)]   = fr.indirect_draw_count;
        buffers[static_cast<uint8_t>(Renderer_Buffer::SkinningBones)]       = fr.skinning_bones;
        buffers[static_cast<uint8_t>(Renderer_Buffer::SkinningJobs)]        = fr.skinning_jobs;
        buffers[static_cast<uint8_t>(Renderer_Buffer::SkinningDispatchArgs)] = fr.skinning_dispatch_args;
    }

    RHI_Texture* Renderer::GetStandardTexture(const Renderer_StandardTexture type)
    {
        return standard_textures[static_cast<uint8_t>(type)].get();
    }

    shared_ptr<Mesh>& Renderer::GetStandardMesh(const MeshType type)
    {
        return standard_meshes[static_cast<uint8_t>(type)];
    }

    shared_ptr<Font>& Renderer::GetFont()
    {
        return standard_font;
    }

    shared_ptr<Material>& Renderer::GetStandardMaterial()
    {
        return standard_material;
    }

    void Renderer::ClearMaterialTextureReferences()
    {
        // clear cached texture pointers that become dangling when resource cache shuts down
        if (standard_material)
        {
            standard_material->ClearPackedTextures();
        }
    }
}
